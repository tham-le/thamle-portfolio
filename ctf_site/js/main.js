// Global variables
let ctfEvents = [];
let currentEvent = null;

// Global state management
let portfolioData = {
    writeups: [],
    achievements: [],
    statistics: {},
    categories: new Set(),
    ctfEvents: new Set(),
    difficulties: new Set(['Easy', 'Medium', 'Hard']),
    isLoading: true
};

let currentFilters = {
    category: 'all',
    difficulty: 'all',
    ctf: 'all',
    search: '',
    view: 'grid'
};

// Initialize the elite portfolio system
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Setup the modal
        setupModal();
        
        // Setup tab switching
        setupTabSwitching();
        
        // Load CTF events with enhanced dynamic loading
        await loadCtfEventsEnhanced();
        
        // Display events list
        displayEventsList();
        
        // Hide loading indicator
        document.getElementById('loading').style.display = 'none';
        
    } catch (error) {
        console.error('üö® Portfolio initialization failed:', error);
        showErrorState(error);
    }
});

// Setup tab switching
function setupTabSwitching() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    const allContent = document.getElementById('writeups-container').parentElement;
    const eventsContent = document.getElementById('events-container');
    
    tabButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active class from all buttons
            tabButtons.forEach(b => b.classList.remove('active'));
            
            // Add active class to clicked button
            btn.classList.add('active');
            
            // Get the view to show
            const view = btn.getAttribute('data-view');
            
            // Hide all content sections
            allContent.classList.add('hidden');
            eventsContent.classList.add('hidden');
            
            // Show appropriate content
            if (view === 'all' && currentEvent) {
                // Show current event's writeups
                allContent.classList.remove('hidden');
            } else if (view === 'events') {
                // Show events list
                eventsContent.classList.remove('hidden');
                // Reset current event when going back to events list
                currentEvent = null;
                
                // Update page title
                document.title = "Tham's CTF Writeups";
            } else {
                // Default to events list
                eventsContent.classList.remove('hidden');
                // Activate events tab
                document.querySelector('[data-view="events"]').classList.add('active');
            }
        });
    });
}

// Load CTF events from index.md
async function loadCtfEvents() {
    try {
        // Fetch the master index
        const indexResponse = await fetch('assets/writeups/index.md');
        if (!indexResponse.ok) {
            throw new Error(`Failed to fetch index: ${indexResponse.status}`);
        }
        
        const indexContent = await indexResponse.text();
        
        // Parse the index to get CTF events
        const ctfEventMatches = [...indexContent.matchAll(/\[([^\]]+)\]\(\.\/([^\/]+)\/\)/g)];
        
        // Extract event names and paths
        ctfEvents = ctfEventMatches.map(match => ({
            name: match[1],
            path: match[2]
        }));
        
        console.log(`Loaded ${ctfEvents.length} CTF events`);
    } catch (error) {
        console.error('Error loading CTF events:', error);
        throw error;
    }
}

// Load portfolio statistics and writeup data from the sync workflow
async function loadPortfolioData() {
    try {
        // Try to load the statistics file generated by the sync workflow
        const statsResponse = await fetch('assets/stats.json');
        if (statsResponse.ok) {
            const stats = await statsResponse.json();
            
            portfolioData.statistics = stats;
            portfolioData.writeups = stats.writeup_list || [];
            portfolioData.achievements = stats.achievements || [];
            
            // Extract unique values for filters
            stats.writeup_list?.forEach(writeup => {
                portfolioData.categories.add(writeup.category);
                portfolioData.ctfEvents.add(writeup.ctf);
                portfolioData.difficulties.add(writeup.difficulty);
            });
            
            console.log(`üìä Loaded portfolio data: ${portfolioData.writeups.length} writeups from ${portfolioData.ctfEvents.size} CTF events`);
            return true;
        }
    } catch (error) {
        console.warn('üìä Could not load portfolio statistics:', error);
    }
    
    return false;
}

// Enhanced CTF event loading with dynamic data
async function loadCtfEventsEnhanced() {
    try {
        // First, try to load from the statistics file
        const hasStats = await loadPortfolioData();
        
        if (hasStats && portfolioData.statistics.writeup_list) {
            // Create CTF events from the statistics
            const ctfGroups = {};
            portfolioData.statistics.writeup_list.forEach(writeup => {
                if (!ctfGroups[writeup.ctf]) {
                    ctfGroups[writeup.ctf] = {
                        name: writeup.ctf,
                        path: writeup.ctf,
                        writeups: []
                    };
                }
                ctfGroups[writeup.ctf].writeups.push(writeup);
            });
            
            ctfEvents = Object.values(ctfGroups);
            console.log(`üîó Loaded ${ctfEvents.length} CTF events from statistics`);
        } else {
            // Fallback to the original method
            await loadCtfEvents();
        }
    } catch (error) {
        console.error('‚ùå Failed to load CTF events:', error);
        // Fallback to original method
        await loadCtfEvents();
    }
}

// Display events list
function displayEventsList() {
    const container = document.getElementById('events-container');
    if (!container) {
        console.error('Events container not found');
        return;
    }
    
    container.innerHTML = '<h2 class="section-title">üèÜ CTF Events Portfolio</h2>';
    
    if (ctfEvents.length === 0) {
        container.innerHTML += `
            <div class="no-events">
                <p>üå∏ Welcome to Tham's Pixel CTF Adventure! üå∏</p>
                <p>‚ú® No CTF quests loaded yet! This could be because:</p>
                <ul>
                    <li>üîÑ The magical sync spell hasn't been cast recently</li>
                    <li>üìö No adventure scrolls are available in the external library</li>
                    <li>‚è≥ The pixelated content is still materializing</li>
                    <li>üéÆ The CTF dimension portal is still opening</li>
                </ul>
                <p>üéØ Please check back later or ask the wizard to trigger a manual sync!</p>
                <div class="kawaii-loading">
                    <span class="loading-pixel">üéÆ</span>
                    <span class="loading-pixel">üå∏</span>
                    <span class="loading-pixel">‚≠ê</span>
                    <span class="loading-pixel">üöÄ</span>
                </div>
            </div>
        `;
        return;
    }
    
    // Group events by year if they have a year in the name
    const eventsByYear = {};
    
    ctfEvents.forEach(event => {
        // Try to extract year from event name (assuming format like 'EventName 2023')
        const yearMatch = event.name.match(/\b(20\d{2})\b/);
        const year = yearMatch ? yearMatch[1] : 'Other';
        
        if (!eventsByYear[year]) {
            eventsByYear[year] = [];
        }
        
        eventsByYear[year].push(event);
    });
    
    // Create the events display
    const eventsGrid = document.createElement('div');
    eventsGrid.className = 'events-grid';
    
    Object.keys(eventsByYear).sort().reverse().forEach(year => {
        const yearSection = document.createElement('div');
        yearSection.className = 'year-section';
        
        const yearHeader = document.createElement('h3');
        yearHeader.className = 'year-header';
        yearHeader.textContent = year === 'Other' ? 'Other Events' : `${year} Events`;
        yearSection.appendChild(yearHeader);
        
        eventsByYear[year].forEach(event => {
            const eventCard = createEventCard(event);
            yearSection.appendChild(eventCard);
        });
        
        eventsGrid.appendChild(yearSection);
    });
    
    container.appendChild(eventsGrid);
}

// Create event card
function createEventCard(event) {
    const eventCard = document.createElement('div');
    eventCard.className = 'event-card';
    
    // Calculate event statistics
    const writeupCount = event.writeups ? event.writeups.length : 0;
    const totalPoints = event.writeups ? event.writeups.reduce((sum, w) => sum + (w.points || 0), 0) : 0;
    const categories = event.writeups ? [...new Set(event.writeups.map(w => w.category))].sort() : [];
    
    eventCard.innerHTML = `
        <div class="event-header">
            <h3 class="event-title">${event.name}</h3>
            <div class="event-stats">
                <span class="stat">üìù ${writeupCount} writeups</span>
                <span class="stat">‚≠ê ${totalPoints} points</span>
            </div>
        </div>
        <div class="event-categories">
            ${categories.map(cat => `<span class="category-tag category-${cat}">${cat}</span>`).join('')}
        </div>
        <div class="event-actions">
            <button class="btn-primary" onclick="loadEventContent('${event.path}')">
                üìñ View Event & Writeups
            </button>
        </div>
    `;
    
    return eventCard;
}

// üèÜ Display events view
function displayEventsView() {
    const container = document.getElementById('events-container');
    if (!container) return;
    
    container.innerHTML = '<h2 class="section-title">üèÜ CTF Events Portfolio</h2>';
    
    const eventsGrid = document.createElement('div');
    eventsGrid.className = 'events-grid';
    
    [...portfolioData.ctfEvents].sort().forEach(ctfEvent => {
        const eventWriteups = portfolioData.writeups.filter(w => w.ctf === ctfEvent);
        const totalPoints = eventWriteups.reduce((sum, w) => sum + w.points, 0);
        const categories = [...new Set(eventWriteups.map(w => w.category))];
        
        const yearEvents = document.createElement('div');
        yearEvents.className = 'year-events';
        
        // Create event cards for this year
        eventsByYear[year].forEach(event => {
            const eventCard = document.createElement('div');
            eventCard.className = 'event-card';
            eventCard.innerHTML = `<h3>${event.name}</h3>`;
            
            // Preload README to get a description if available
            fetch(`assets/writeups/${event.path}/README.md`)
                .then(response => {
                    if (response.ok) {
                        return response.text();
                    }
                    return '';
                })
                .then(content => {
                    // Try to extract a short description
                    const descMatch = content.match(/^(?!#)(.{10,100})(?=\n)/);
                    if (descMatch) {
                        const desc = document.createElement('p');
                        desc.className = 'event-description';
                        desc.textContent = descMatch[1].trim() + '...';
                        eventCard.appendChild(desc);
                    }
                })
                .catch(err => console.warn(`Could not load description for ${event.name}`, err));
            
            eventCard.addEventListener('click', () => {
                loadEventDetails(event);
            });
            
            yearEvents.appendChild(eventCard);
        });
        
        eventsGrid.appendChild(yearEvents);
    });
    
    container.appendChild(eventsGrid);
}

// Load event details and writeups
async function loadEventDetails(event) {
    try {
        currentEvent = event;
        
        // Show the writeups container
        const writeupSection = document.getElementById('writeups-container').parentElement;
        writeupSection.classList.remove('hidden');
        
        // Hide events container
        document.getElementById('events-container').classList.add('hidden');
        
        // Switch to "all" tab
        document.querySelector('[data-view="all"]').classList.add('active');
        document.querySelector('[data-view="events"]').classList.remove('active');
        
        // Show loading indicator
        const loadingEl = document.getElementById('loading');
        loadingEl.style.display = 'flex';
        
        // Load event README
        const readmeUrl = `assets/writeups/${event.path}/README.md`;
        const readmeResponse = await fetch(readmeUrl);
        let readmeContent = null;
        let hasReadme = false;
        
        if (readmeResponse.ok) {
            readmeContent = await readmeResponse.text();
            hasReadme = true;
        }
        
        // Check for categories and writeups
        let writeupCategories = [];
        
        // If we have a README, try to find categories from it
        if (hasReadme) {
            // Display event detail with README
            displayEventDetail(event, readmeContent);
            
            // Find all writeups links in README
            writeupCategories = [...readmeContent.matchAll(/\*\*\[([^\]]+)\]\(\.\/([^\/]+)\/\)\*\*/g)];
        } else {
            // If no README, just display the event header
            displayEventHeader(event);
            
            // Try common categories when README is not available
            const commonCategories = [
                ['web', 'web'], 
                ['crypto', 'crypto'], 
                ['pwn', 'pwn'], 
                ['rev', 'rev'], 
                ['forensics', 'forensics'], 
                ['misc', 'misc']
            ];
            writeupCategories = commonCategories;
        }
        
        // Load writeup list for each category
        const writeups = [];
        for (const link of writeupCategories) {
            const category = link[0] || link;
            const categoryPath = link[1] || link;
            
            // Try to load writeups from this category
            const categoryWriteups = await loadCategoryWriteups(event, category, categoryPath);
            writeups.push(...categoryWriteups);
        }
        
        // Display writeups list
        displayWriteupsList(event, writeups);
        
        // Hide loading indicator
        loadingEl.style.display = 'none';
        
        // Scroll to top
        window.scrollTo(0, 0);
        
    } catch (error) {
        console.error('Error loading event details:', error);
        document.getElementById('loading').innerHTML = `
            <div class="error">
                <p>Error loading event details. Please try again later.</p>
                <p class="error-details">Details: ${error.message}</p>
            </div>
        `;
    }
}

// Load writeups from a category
async function loadCategoryWriteups(event, category, categoryPath) {
    try {
        const writeups = [];
        
        // Try to detect writeups by fetching common markdown files in the category folder
        // We'll check for .md files in a pattern
        const possibleExtensions = ['.md', '.markdown'];
        
        // For each possible file, try to fetch it
        // We'll try a few common patterns
        const patternFiles = [
            // Try direct fetch without guessing
            async () => {
                try {
                    // First, try to fetch a category index file if it exists
                    const indexPath = `assets/writeups/${event.path}/${categoryPath}/index.md`;
                    const indexResponse = await fetch(indexPath);
                    
                    if (indexResponse.ok) {
                        const indexContent = await indexResponse.text();
                        
                        // Extract links from the index file
                        const matches = [...indexContent.matchAll(/\[([^\]]+)\]\(([^)]+)\)/g)];
                        
                        for (const match of matches) {
                            const title = match[1];
                            let filepath = match[2];
                            
                            // Handle relative paths
                            if (filepath.startsWith('./')) {
                                filepath = filepath.substring(2);
                            }
                            
                            // Construct the full path
                            const fullPath = `assets/writeups/${event.path}/${categoryPath}/${filepath}`;
                            
                            // Try to fetch the file
                            const response = await fetch(fullPath);
                            if (!response.ok) continue;
                            
                            const content = await response.text();
                            
                            writeups.push({
                                title: title,
                                filepath: fullPath,
                                category: category,
                                filename: filepath
                            });
                        }
                        
                        return writeups.length > 0;
                    }
                } catch (err) {
                    console.warn("Error fetching category index file:", err);
                }
                return false;
            },
            
            // Common specific filenames for this event and category
            async () => {
                // Known common patterns based on the event and category
                let knownPatterns = {
                    'ExampleCTF2025': {
                        'web': ['xss-challenge.md', 'sql-injection.md', 'jwt-bypass.md'],
                        'crypto': ['rsa-crack.md', 'aes-ecb.md'],
                        'forensics': ['hidden-data.md'],
                        'pwn': ['buffer-overflow.md'],
                    },
                    'IrisCTF2025': {
                        'web': ['ssrf.md', 'prototype-pollution.md'],
                        'crypto': ['substitution.md']
                    }
                };
                
                // Get known patterns for this event and category
                const patterns = knownPatterns[event.path]?.[categoryPath] || [];
                
                for (const pattern of patterns) {
                    const filepath = `assets/writeups/${event.path}/${categoryPath}/${pattern}`;
                    
                    try {
                        const response = await fetch(filepath);
                        if (!response.ok) continue;
                        
                        const content = await response.text();
                        
                        // Extract title from frontmatter or heading
                        let title = pattern.replace('.md', '').replace(/-/g, ' ');
                        
                        // Try to get title from frontmatter
                        const frontmatterMatch = content.match(/---\s+([\s\S]*?)\s+---/);
                        if (frontmatterMatch) {
                            const frontmatter = frontmatterMatch[1];
                            const titleMatch = frontmatter.match(/title:\s*["']?([^"'\n]+)["']?/);
                            if (titleMatch) {
                                title = titleMatch[1];
                            }
                        } else {
                            // Try to get title from first heading
                            const headingMatch = content.match(/^#\s+(.+)$/m);
                            if (headingMatch) {
                                title = headingMatch[1];
                            }
                        }
                        
                        writeups.push({
                            title: title,
                            filepath: filepath,
                            category: category,
                            filename: pattern
                        });
                    } catch (err) {
                        console.warn(`Failed to load writeup ${pattern}:`, err);
                    }
                }
                
                return writeups.length > 0;
            }
        ];
        
        // Try each pattern until one succeeds
        for (const patternFn of patternFiles) {
            const success = await patternFn();
            if (success) break;
        }
        
        return writeups;
    } catch (error) {
        console.error(`Error loading writeups for ${category}:`, error);
        return [];
    }
}

// Display just the event header (for when there's no README)
function displayEventHeader(event) {
    const container = document.getElementById('writeups-container');
    
    // Create event detail container
    const eventDetail = document.createElement('div');
    eventDetail.className = 'event-detail';
    
    // Add header with back button and event title
    const header = document.createElement('div');
    header.className = 'event-detail-header';
    
    // Back button
    const backButton = document.createElement('button');
    backButton.className = 'back-btn';
    backButton.textContent = '‚Üê Back to Events';
    backButton.addEventListener('click', () => {
        // Switch back to events view
        document.querySelector('[data-view="events"]').click();
    });
    
    header.appendChild(backButton);
    
    // Add event title
    const eventTitle = document.createElement('h1');
    eventTitle.className = 'event-title';
    eventTitle.textContent = event.name;
    header.appendChild(eventTitle);
    
    eventDetail.appendChild(header);
    
    // Clear container and add event detail
    container.innerHTML = '';
    container.appendChild(eventDetail);
}

// Display event detail with README content
function displayEventDetail(event, readmeContent) {
    const container = document.getElementById('writeups-container');
    
    // Create event detail container
    const eventDetail = document.createElement('div');
    eventDetail.className = 'event-detail';
    
    // Add back button header
    const header = document.createElement('div');
    header.className = 'event-detail-header';
    
    // Back button
    const backButton = document.createElement('button');
    backButton.className = 'back-btn';
    backButton.textContent = '‚Üê Back to Events';
    backButton.addEventListener('click', () => {
        // Switch back to events view
        document.querySelector('[data-view="events"]').click();
    });
    
    header.appendChild(backButton);
    eventDetail.appendChild(header);
    
    // Add readme content
    const readmeElement = document.createElement('div');
    readmeElement.className = 'event-readme markdown-content';
    readmeElement.innerHTML = marked.parse(readmeContent);
    eventDetail.appendChild(readmeElement);
    
    // Clear container and add event detail
    container.innerHTML = '';
    container.appendChild(eventDetail);
}

// Display writeups list
function displayWriteupsList(event, writeups) {
    const container = document.getElementById('writeups-container');
    
    // Create writeups list container
    const writeupsList = document.createElement('div');
    writeupsList.className = 'writeups-list';
    
    // Add heading
    const heading = document.createElement('h2');
    heading.className = 'writeups-heading';
    heading.textContent = 'Challenge Writeups';
    writeupsList.appendChild(heading);
    
    if (writeups.length === 0) {
        const noWriteups = document.createElement('p');
        noWriteups.className = 'no-writeups';
        noWriteups.textContent = 'No writeups available for this event yet.';
        writeupsList.appendChild(noWriteups);
    } else {
        // Group writeups by category
        const writeupsByCategory = {};
        writeups.forEach(writeup => {
            if (!writeupsByCategory[writeup.category]) {
                writeupsByCategory[writeup.category] = [];
            }
            writeupsByCategory[writeup.category].push(writeup);
        });
        
        // Display each category
        Object.keys(writeupsByCategory).sort().forEach(category => {
            const categorySection = document.createElement('div');
            categorySection.className = 'writeup-category-section';
            
            const categoryTitle = document.createElement('h3');
            categoryTitle.className = 'category-title';
            categoryTitle.textContent = category;
            categorySection.appendChild(categoryTitle);
            
            const categoryWriteups = document.createElement('ul');
            categoryWriteups.className = 'writeup-links';
            
            writeupsByCategory[category].forEach(writeup => {
                const item = document.createElement('li');
                const link = document.createElement('a');
                link.textContent = writeup.title;
                link.href = '#';
                link.setAttribute('data-filepath', writeup.filepath);
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    loadWriteupContent(writeup);
                });
                
                item.appendChild(link);
                categoryWriteups.appendChild(item);
            });
            
            categorySection.appendChild(categoryWriteups);
            writeupsList.appendChild(categorySection);
        });
    }
    
    // Append to container
    container.appendChild(writeupsList);
}

// Load and show a specific writeup
async function loadWriteupContent(writeup) {
    try {
        // Show loading indicator
        const modal = document.getElementById('writeup-modal');
        const modalBody = document.getElementById('modal-body');
        
        modalBody.innerHTML = `
            <div class="loading-modal">
                <div class="pixel-loader"></div>
                <p>Loading writeup...</p>
            </div>
        `;
        
        modal.style.display = 'block';
        
        // Set modal title
        document.getElementById('modal-title').textContent = writeup.title;
        
        // Fetch writeup content
        const response = await fetch(writeup.filepath);
        
        if (!response.ok) {
            throw new Error(`Failed to load writeup: ${response.status}`);
        }
        
        const content = await response.text();
        
        // Process content (convert markdown to HTML)
        const htmlContent = marked.parse(content);
        
        // Add to modal
        modalBody.innerHTML = `<div class="markdown-content">${htmlContent}</div>`;
        
        // Add syntax highlighting
        setTimeout(() => {
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        }, 100);
        
    } catch (error) {
        console.error('Error loading writeup:', error);
        document.getElementById('modal-body').innerHTML = `
            <div class="error">
                <p>Error loading writeup. Please try again later.</p>
                <p class="error-details">Details: ${error.message}</p>
            </div>
        `;
    }
}

// Setup modal functions
function setupModal() {
    const modal = document.getElementById('writeup-modal');
    const closeBtn = document.querySelector('.close-modal');
    
    closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    // Close when clicking outside the modal content
    window.addEventListener('click', (event) => {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
    
    // Prevent scrolling of the body when modal is open
    modal.addEventListener('scroll', (e) => {
        e.stopPropagation();
    });
}

// Enhanced error state display
function showErrorState(error) {
    const loadingEl = document.getElementById('loading');
    loadingEl.innerHTML = `
        <div class="error-state">
            <h2>üö® Portfolio Loading Error</h2>
            <p>Unable to load CTF writeups. Please try refreshing the page.</p>
            <p class="error-details">Technical details: ${error.message}</p>
            <button onclick="location.reload()" class="retry-btn">üîÑ Retry</button>
        </div>
    `;
    loadingEl.style.display = 'flex';
}

// üìä Performance monitoring for production
function initPerformanceMonitoring() {
    if ('performance' in window) {
        window.addEventListener('load', () => {
            const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
            
            // Only log performance in development
            if (window.location.hostname === 'localhost' || window.location.hostname.includes('localhost')) {
                console.log(`‚ö° Page loaded in ${loadTime}ms`);
            }
            
            // Send analytics in production (if needed)
            if (loadTime > 3000) {
                console.warn('‚ö†Ô∏è Slow page load detected');
            }
        });
    }
}

// Initialize performance monitoring
initPerformanceMonitoring();
